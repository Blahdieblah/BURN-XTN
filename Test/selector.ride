{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# IMPORT artifacts/mainnet.ride #-}

func tryGetInteger (address:Address, key:String)= match getInteger(address, key) {
    case b: Int => 
        b
    case _ => 
        0
}

let d6 = 1000000
let d8 = 100000000
let d16 = (d8 * d8)

let invoker = Address(base58'3P4AdC9J6MzTEi2LL9xgQN8EimMnbk4d6Nt')
let project = Address(base58'3PCBL2vbjAVFbiCwmGsPmT6QdATutQnM8ov') # test 
#let project = Address(base58'3PAucbbumdUXmhzcR421zGiayphEdo2tRoz') # live

let poolId = base58'3PE7NtJdmVq4yo47LKDqurQ8RLDCouvJCPB'
let poolString = toBase58String(poolId)
let pool2 = base58'3PQHndCUVrv3wBuQjbvVP9SnGmfbfitGxfx'
let poolMega = base58'3PBiMQLnX8wd4bssXCgF8KuUqHv1H4zWHGi'
let poolBBB = base58'3P9VPwVfNj3dDevQZt1Z951A4K57cmQmCgk'
let poolLP = base58'3PQoBfUKHkJAeGWhooLP7WS8ovb54av9Jp2'

let pzBurnxtn = base58'GdrDHazRGcCYeCgDEZzLpsZ3E7jmrxYB7EDUiGfiVAr1'
let pzBBB = base58'AE12ZN9PQyPKHR5CqR2Qau31JqS68rZbVYxaJbRM8kFj'

let xtnId = base58'DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p'
let burnxtnId = base58'3SjxA2YLdfF9fTRbzLm9xFn27C6MW34W1YsdJ6Axefns'
let burnxtnString = toBase58String(burnxtnId)

let westId = base58'4LHHvYGNKJUg5hj65aGD5vgScvCBmLpdRFtjokvCjSL8'
let viresId = base58'DSbbhLsSTeDg5Lsiufk2Aneh3DjVqJuPr2M9uU1gwy5p'
let eggId = base58'C1iWsKGqLwjHUndiQ7iXpdmPum9PeCDFfyXBdJJosDRS'
let surfId = base58'At8D6NFFpheCbvKVnjVoeLL84Eo8NZn6ovManxfLaFWL'
let nsbtId = base58'6nSpVyNH7yM69eg446wrQR94ipbbcmZMU1ENPwanC97g'
let wxId = base58'Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on'
let swopId = base58'Ehie5xYpeN8op1Cctc6aGUrqx8jq3jtf1DSjXDbfm7aT'
let wavesId = base58'WAVES'
let usdterc = base58'9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi'
let usdcerc = base58'HGgabTqUS8WtVFUJzfmrTDMgEccJuZLBPhFgQFxvnsoW'
let usdtbsc = base58'A81p1LTRyoq2rDR2TNxB2dWYxsiNwCSSi8sXef2SEkwb'
let usdcbsc = base58'4BKKSp6NoNcrFHyorZogDyctq1fq6w7114Ym1pw6HUtC'
let swaves = base58'YiNbofFzC17jEHHCMwrRcpy9MrrjabMMLZxg8g5xmf7'
let puzzle = base58'HEB8Qaw9xrWpWs8tHsiATYGBWDBtP2S7kcPALrMu43AS'
let whirlpool = base58'73tY3E6Gd5AWYmsuq8m8Kek7KnJNAYyS3GoveTbc6jCi'
let rome = base58'AP4Cb5xLYGH6ZigHreCZHoXpQTWDkPsG2BHqfDUx6taJ'
let vvxtnlp = base58'8KEtor9aSsSj38MknyAE7k1uRThHY9prAXgiE4D7WpyL'

let keyInvokeNext = "invoke next"

# calculate value of sWAVES to WAVES
let SWAVES_stake = Address(base58'3PDPzZVLhN1EuzGy4xAxjjTVkawKDLEaHiV')
func _loadInt (key_:String,default_:Int) = match getInteger(SWAVES_stake, key_) {
    case a: Int => 
        a
    case _ => 
        default_
}

func _loadBigInt (key_:String,default_:BigInt) = match getBinary(SWAVES_stake, key_) {
    case a: ByteVector => 
        toBigInt(a)
    case _ => 
        default_
}

    let WX_BURNXTN_WAVES = Address(base58'3P5vwLbXddLWpsRspftMxLuzfsjk3dLT3n5')
    let lastRate = _loadBigInt("LAST_RATE", toBigInt(1000000000000))
    let currentRate = _loadBigInt("CURRENT_RATE", toBigInt(0))
    let lastHeight = _loadInt("LAST_HEIGHT", 0)
    let targetHeight = min([_loadInt("TARGET_HEIGHT", 0), height])
    let lastRateUpdated = (lastRate + (currentRate * toBigInt((targetHeight - lastHeight))))
    let baseAmount = toInt(fraction(toBigInt(assetBalance(WX_BURNXTN_WAVES, swaves)), lastRateUpdated, toBigInt(1000000000000), FLOOR))

let wavesInWX = wavesBalance(WX_BURNXTN_WAVES).regular + baseAmount
let burnxtnInWX = assetBalance(WX_BURNXTN_WAVES, burnxtnId)
let burnxtnwavesprice = fraction(d8 , wavesInWX, burnxtnInWX)

let burnxtnbalance2 = assetBalance(Address(pool2), burnxtnId)
let usdbalance = (assetBalance(Address(pool2), usdterc) + assetBalance(Address(pool2), usdcerc) + assetBalance(Address(pool2), usdtbsc) + assetBalance(Address(pool2), usdcbsc)) / 4
let burnxtnusdprice = fraction(d8, usdbalance, burnxtnbalance2) 

let ATH = if burnxtnwavesprice > getIntegerValue("ATH in wavelets") then burnxtnwavesprice else getIntegerValue(this, "ATH in wavelets")
let ATHusd = if burnxtnusdprice > getIntegerValue("ATH in centlets") then burnxtnusdprice else getIntegerValue(this, "ATH in centlets")

let wavesinpool = getIntegerValue(Address(poolId), ("global_" + toBase58String(wavesId)) + "_balance")
let projectstake = getIntegerValue(Address(poolId), ("3PAucbbumdUXmhzcR421zGiayphEdo2tRoz" + "_indexStaked"))
let totalstake = getIntegerValue(Address(poolId), ("global_poolToken_amount"))
let tvlinwaves = fraction(fraction(wavesinpool, projectstake, totalstake), 9, d8)
let tvlpool = fraction(wavesinpool, 9, d8)

let pricegrowth = (fraction(d8, burnxtnwavesprice, getIntegerValue(this, "intial price BURN-XTN in wavelets")) - d8) / 1000000

let PL_Defi = Address(base58'3P4DK5VzDwL3vfc5ahUEhtoe5ByZNyacJ3X')

func PL_value(dAppAddress:Address, asset:ByteVector)=
{
  fraction(getIntegerValue(dAppAddress, (toString(this) + "_supplied_" + toBase58String(asset))), 
  getIntegerValue(dAppAddress, (toBase58String(asset) + "_sRate")), 
  d16)
}

# swap WX pools
func swapWX(assetIn:ByteVector, assetOut:ByteVector, amountIn:Int)=
{
  invoke(Address(base58'3P68zNiufsu1viZpu1aY3cdahRRKcvV5N93'), "swap", [fraction(amountIn, 11, 10), toBase58String(assetOut), toString(this)], [AttachedPayment(assetIn, amountIn)])
}

# calculate WX pool price
let VVXTNLP_XTN_AMM = Address(base58'3P9UJxhsqj1UkqPDtM16yi9aGE26V5tdH6i')
let XTNbalance = assetBalance(VVXTNLP_XTN_AMM, xtnId)
let VVXTNLPbalance = assetBalance(VVXTNLP_XTN_AMM, vvxtnlp)
let VVXTNLPprice = fraction(XTNbalance, 100, VVXTNLPbalance)

@Callable(i)
func PZbbb()=
if (i.caller != this) then throw("access only by project owner") else
{
    strict swapSwop = invoke(Address(poolId), "swap", [toBase58String(burnxtnId), 0], [AttachedPayment(swopId, assetBalance(this, swopId))])
    strict inv =  if (assetBalance(this, burnxtnId) > 0) then
      invoke(Address(poolLP), "generateWithOneToken", [toBase58String(poolBBB)], [AttachedPayment(burnxtnId, assetBalance(this, burnxtnId))]) else unit
    [IntegerEntry(keyInvokeNext, 31)]
}

@Callable(i)
func burnSURF()=
if (i.caller != this) then throw("access only by project owner") else
{
    strict swapWhirl = invoke(Address(poolBBB), "swap", [toBase58String(burnxtnId), 0], [AttachedPayment(whirlpool, assetBalance(this, whirlpool))])
    strict swapRome = invoke(Address(poolBBB), "swap", [toBase58String(burnxtnId), 0], [AttachedPayment(rome, assetBalance(this, rome))])    
    strict swapWaves = invoke(Address(poolId), "swap", [toBase58String(surfId), 0], [AttachedPayment(unit, tryGetInteger(this, "waves amount to swap"))])

    let surfBurnAmount = assetBalance(this, surfId)
    let surfBurn = Burn(surfId, surfBurnAmount)
    [
    surfBurn,
    IntegerEntry("SURF total burned", tryGetInteger(this, "SURF total burned") + surfBurnAmount),
    IntegerEntry(keyInvokeNext, 40) # 33
    ]
}

@Callable(i)
func SURFandVVXTNLP()=
{
    strict stakeSurf = if (assetBalance(this, surfId) > 0) then
      invoke(Address(base58'3P4DK5VzDwL3vfc5ahUEhtoe5ByZNyacJ3X'), "supply", [], [AttachedPayment(surfId, assetBalance(this, surfId))]) else unit
    strict swapXTNtoVVXTNLP = if (assetBalance(this, xtnId) > 0) && (VVXTNLPprice < 80) then 
      swapWX(xtnId, vvxtnlp, assetBalance(this, xtnId)) else unit
    [IntegerEntry(keyInvokeNext, if (burnxtnwavesprice >= getIntegerValue(this, "ATH in wavelets")) then 10 else 20)]
}

@Callable(i)
func dEntry() =
if (i.caller != this) then throw("access only by project owner") else{
    [
    IntegerEntry("BURN-XTN / WAVES price in wavelets", burnxtnwavesprice),
    IntegerEntry("Price growth %", pricegrowth),
    IntegerEntry("ATH in wavelets", ATH),
    IntegerEntry("BURN-XTN / USD price in centlets", burnxtnusdprice),
    IntegerEntry("ATH in centlets", ATHusd),
    IntegerEntry("TVL project in WAVES excluding BURN-XTN", tvlinwaves),
    IntegerEntry("TVL pool in WAVES excluding BURN-XTN", tvlpool),
    IntegerEntry("Activated blockheight", height),
    IntegerEntry("BURN-XTN supply", match assetInfo(burnxtnId) {
    case asset:Asset =>
        asset.quantity / d8
    case _ => throw("Can't find asset")
    }),
    IntegerEntry("BURN-XTN total burned", 1000000000 - match assetInfo(burnxtnId) {
    case asset:Asset =>
        asset.quantity / d8
    case _ => throw("Can't find asset")
    }),
    IntegerEntry("SURF supply", match assetInfo(surfId) {
    case asset:Asset =>
        asset.quantity / d6
    case _ => throw("Can't find asset") 
    }),
    IntegerEntry("total SURF PL Waves Defi", PL_value(PL_Defi, surfId)),
    IntegerEntry(keyInvokeNext, 0)
    ]
}

@Callable(i)
func burnBURNXTN()= 
if (i.caller != this) then throw("access only by project owner") else {
  let burnxtnBurn = Burn(burnxtnId, assetBalance(this, burnxtnId))
  [
  burnxtnBurn,
  IntegerEntry(keyInvokeNext, 11)
  ]
}

@Callable(i)
func pump()= 
if (i.caller != this) then throw("access only by project owner") else {
  strict swest = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(westId,assetBalance(this, westId))])
  strict svires = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(viresId,assetBalance(this, viresId))])
  strict segg = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(eggId,assetBalance(this, eggId))])
  strict snsbt = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(nsbtId,assetBalance(this, nsbtId))])
  strict swapwaves = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(unit,if wavesBalance(this).available - d8 > 0
    then wavesBalance(this).available - d8
    else 0)])
    [
    Burn(burnxtnId, assetBalance(this, burnxtnId)),
    IntegerEntry(keyInvokeNext, 30)
    ]
}

# If func dEntry is not invoked in 8 days, then function PumpByAnybody, can be called by anybody. (This is tokenomics mode: burn XTN fees, buyback & burn BURN-XTN).
@Callable(i)
func PumpByAnybody() = 
if height < getIntegerValue(this, "Activated blockheight") + 8 * 1440 then throw("Wait till blockheight:" + toString(getIntegerValue(this, "Activated blockheight") + 8 * 1440)) else{
  strict claimInv = invoke(Address(base58'3PE7NtJdmVq4yo47LKDqurQ8RLDCouvJCPB'), "claimIndexRewards", [], [])
  strict swest = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(westId,assetBalance(this, westId))])
  strict svires = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(viresId,assetBalance(this, viresId))])
  strict segg = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(eggId,assetBalance(this, eggId))])
  strict ssurf = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(surfId,assetBalance(this, surfId))])
  strict snsbt = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(nsbtId,assetBalance(this, nsbtId))])
  strict swx = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(wxId,assetBalance(this, wxId))])
  strict sswop = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(swopId,assetBalance(this, swopId))])
  strict swapwaves = invoke(Address(poolId), "swap", [burnxtnString,0], [AttachedPayment(unit,if wavesBalance(this).available - d8 > 0
then wavesBalance(this).available - d8
else 0)])
  let xtnburnamount = assetBalance(this, xtnId)
  let xtnBurn = Burn(xtnId, xtnburnamount)
  let burnxtnBurn = Burn(burnxtnId, assetBalance(this, burnxtnId))
    [
    xtnBurn,
    burnxtnBurn,
    IntegerEntry("BURN-XTN supply", match assetInfo(burnxtnId) {
    case asset:Asset =>
        asset.quantity / d8
    case _ => throw("Can't find asset")
}),
    IntegerEntry("BURN-XTN total burned", 1000000000 - match assetInfo(burnxtnId) {
    case asset:Asset =>
        asset.quantity / d8
    case _ => throw("Can't find asset")
}),
IntegerEntry("XTN total burned", getIntegerValue(this, "XTN total burned") + xtnburnamount)
    ]
}

@Callable(i)
func withdraw() = {
  if (i.caller != Address(base58'3P4AdC9J6MzTEi2LL9xgQN8EimMnbk4d6Nt')) then throw("no access") else
  strict withdraw = invoke(Address(base58'3PCbvPVQfSvVu88ip8Fm5YjwJhjEYk1Txhk'), "withdrawVestedAllUSDN", [false, true], [])
  []
}

@Callable(i)
func importVVXTNLP()=
{
    if (i.caller != Address(base58'3P4AdC9J6MzTEi2LL9xgQN8EimMnbk4d6Nt')) then throw("no access") else
    strict import = invoke(Address(base58'3PCbvPVQfSvVu88ip8Fm5YjwJhjEYk1Txhk'), "importLP", [], [AttachedPayment(vvxtnlp, assetBalance(this, vvxtnlp))])
    []
}

@Callable(i)
func burnXTNandClaim() = 
if (i.caller != this) then throw("access only by project owner") else {
  strict invc = invoke(Address(base58'3PE7NtJdmVq4yo47LKDqurQ8RLDCouvJCPB'), "claimIndexRewards", [], [])
  let xtnburnamount = assetBalance(this, xtnId)
  let xtnBurn = Burn(xtnId, xtnburnamount)
    [
    xtnBurn,
    IntegerEntry("XTN total burned", getIntegerValue(this, "XTN total burned") + xtnburnamount),
    IntegerEntry("XTN supply", match assetInfo(xtnId) {
    case asset:Asset =>
        (asset.quantity - assetBalance(Address(base58'3PC9BfRwJWWiw9AREE2B3eWzCks3CYtg4yo'), xtnId)) / d6
    case _ => throw("Can't find asset")
    }),
    IntegerEntry(keyInvokeNext, 01)
    ]
}

@Callable(i)
func claimBBB()= 
if (i.caller != this) then throw("access only by project owner") else {
    strict wavesBalanceBefore = wavesBalance(this).available
    strict claimInv = invoke(addressFromStringValue(toBase58String(poolBBB)), "claimIndexRewards", [], [])
    let wavesDifference = wavesBalance(this).available - wavesBalanceBefore
    [
    IntegerEntry(keyInvokeNext, 32),
    IntegerEntry("waves amount to swap", wavesDifference)
    ]
}

@Callable(i)
func puzzlePZbbb()= 
if (i.caller != this) then throw("access only by project owner") else {
  strict spuzzle = if (assetBalance(this, puzzle) > 0) then
    invoke(Address(poolLP), "generateWithOneToken", [poolBBB], [AttachedPayment(puzzle, assetBalance(this, puzzle))]) else unit
  [IntegerEntry(keyInvokeNext, 40)] # 34
}

@Callable(i)
func stakePZbbb()=
if (i.caller != this && i.caller != invoker) then throw("access only by project owner") else {
  strict stakePZbbb = if (assetBalance(this, pzBBB) > 0) then
    invoke(Address(poolBBB), "stakeIndexFor", [toString(this)], [AttachedPayment(pzBBB, assetBalance(this, pzBBB))]) else unit
  [IntegerEntry(keyInvokeNext, 40)]
}

@Callable(i)
func grow1()= 
if (i.caller != this) then throw("access only by project owner") else {
  strict swest = if (assetBalance(this, westId) > 0) then
    invoke(Address(poolLP), "generateWithOneToken", [poolString], [AttachedPayment(westId,assetBalance(this, westId))]) else unit
  [IntegerEntry(keyInvokeNext, 12)]
}

@Callable(i)
func grow2()= 
if (i.caller != this) then throw("access only by project owner") else {
  strict svires = if (assetBalance(this, viresId) > 0) then
    invoke(Address(poolLP), "generateWithOneToken", [poolString], [AttachedPayment(viresId,assetBalance(this, viresId))]) else unit
  [IntegerEntry(keyInvokeNext, 13)]
}

@Callable(i)
func grow3()= 
if (i.caller != this && i.caller != invoker) then throw("access only by project owner") else {
  strict segg = if (assetBalance(this, eggId) > 0) then
    invoke(Address(poolLP), "generateWithOneToken", [poolString], [AttachedPayment(eggId,assetBalance(this, eggId))]) else unit
  [IntegerEntry(keyInvokeNext, 14)]
}

@Callable(i)
func grow4()= 
if (i.caller != this) then throw("access only by project owner") else {
  strict snsbt = if (assetBalance(this, nsbtId) > 0) then
    invoke(Address(poolLP), "generateWithOneToken", [poolString], [AttachedPayment(nsbtId,assetBalance(this, nsbtId))]) else unit
  [IntegerEntry(keyInvokeNext, 15)]
}

@Callable(i)
func grow5()=
if (i.caller != this) then throw("access only by project owner") else {
  strict swapwaves = if (wavesBalance(this).available - d8 > 0) then
    invoke(Address(poolLP), "generateWithOneToken", [poolString], [AttachedPayment(unit, wavesBalance(this).available - d8)]) else unit
  [IntegerEntry(keyInvokeNext, 16)]
}

@Callable(i)
func grow6()=
if (i.caller != this && i.caller != invoker) then throw("access only by project owner") else {
  strict stakePZburnxtn = if (assetBalance(this, pzBurnxtn) > 0) then
    invoke(Address(base58'3PE7NtJdmVq4yo47LKDqurQ8RLDCouvJCPB'), "stakeIndexFor", [toString(this)], [AttachedPayment(pzBurnxtn, assetBalance(this, pzBurnxtn))]) else unit
  [IntegerEntry(keyInvokeNext, 30)]
}

@Callable(i)
func selector()={
    if (i.caller != Address(base58'3P4AdC9J6MzTEi2LL9xgQN8EimMnbk4d6Nt')) then throw("no access") else
    strict inv00 =
    if (tryGetInteger(this, keyInvokeNext) == 0) then invoke(this, "burnXTNandClaim", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 01) then invoke(this, "SURFandVVXTNLP", [], []) else

    if (tryGetInteger(this, keyInvokeNext) == 10) then invoke(this, "burnBURNXTN", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 11) then invoke(this, "grow1", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 12) then invoke(this, "grow2", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 13) then invoke(this, "grow3", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 14) then invoke(this, "grow4", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 15) then invoke(this, "grow5", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 16) then invoke(this, "grow6", [], []) else

    if (tryGetInteger(this, keyInvokeNext) == 20) then invoke(this, "pump", [], []) else

    if (tryGetInteger(this, keyInvokeNext) == 30) then invoke(this, "PZbbb", [], []) else 
    if (tryGetInteger(this, keyInvokeNext) == 31) then invoke(this, "claimBBB", [], []) else 
    if (tryGetInteger(this, keyInvokeNext) == 32) then invoke(this, "burnSURF", [], []) else 
    if (tryGetInteger(this, keyInvokeNext) == 33) then invoke(this, "puzzlePZbbb", [], []) else
    if (tryGetInteger(this, keyInvokeNext) == 34) then invoke(this, "stakePZbbb", [], []) else

    if (tryGetInteger(this, keyInvokeNext) == 40) then invoke(this, "dEntry", [], []) else unit   
    []
}

@Callable(i)
func changeEntry()=
if (i.caller != this) then throw("access only by project owner") else {
  [IntegerEntry(keyInvokeNext, 40)]
}
